# HashTables, Heaps, and Tries

## HashTables

### 1

What's a suitable `NoItem` object for entries of

- `unsigned int` vs `int`
- `char *`

What if it wasn't open addressed?  (i.e. chaining)

### 2

For chaining what's the best & worst case for 2N inserts (presume insertion is based on comparison costs).

What will be average search cost after insertions are done.

### Example

Let's say we have the hash;

```c
uint64_t hash(int x) {
  // NOTE: Most platforms have int to be 4 bytes but C just specifies
  //       that it is atleast 4 bytes not exactly 4.  So we have to be careful
  //       about casting in the case it is > 8 bytes and our caller is relying on that
  // C11 provides static assert for cases like this.  This will provide error at compile time.
  _Static_assert(sizeof(x) <= 8, "Int must be <= 8 bytes to satisfy cast");
  return (uint64_t)x % 11;
}
```

Insert the following `11  16  27  35  22  20  15  24  29  19  13`.

Note: for the second hash function use `hash2(x) = (x % 3) + 1`

Table:

| Key      | 11 | 16 | 27 | 35 | 22 | 20 | 15 | 24 | 29 | 19 | 13 |
|----------|----|----|----|----|----|----|----|----|----|----|----|
| hash(x)  |  0 |  5 |  5 |  2 |  0 |  9 |  4 |  2 |  7 |  8 |  2 |
| hash2(x) |  3 |  2 |  1 |  3 |  2 |  3 |  1 |  1 |  3 |  2 |  2 |

#### Chaining

> I sometimes call it linear chaining to indicate a linked list since you could use a BST if you know your going to face a high number of collisions

This use of mixing collections is why computer science often is called an 'art' sometimes rather than a direct science.  It's important to be able to mix and match 

#### Linear Probing

Basically just a linear search ones the collision happens

#### Double hashing

Slightly more complex but basically it is just

```c
i = 0;
pos;
do {
   pos = (hash(key) + i * hash2(key)) % len(table);
   i++;
} while collision at pos;
```

## Side note

Some hash functions are listed [here](http://www.cse.yorku.ca/~oz/hash.html)

I personally like djb2 since it's simple and just good for in general.  So I'll rewrite it in more of a 1511/2521 style

```c
// char on most systems is probably unsigned
// but often with hashes because we are shifting
// we really want to make sure it is
unsigned long hash(unsigned char *str) {
    unsigned long hash = 5381;
    size_t pos = 0; // support ridiculously long strings
    while (str[pos] != '\0') {
        // some places do (hash << 5) + hash but it's the same thing
        hash = hash * 33 + str[pos];
        pos++;
    }
    return hash;
}
```

You'll notice all hash algorithms use prime numbers!!

Very popular second hash functions look like; `hash2(key) = PRIME - (key % PRIME)` where `PRIME < len(table)`

> Second hash functions can't evaluate to 0 and must ensure that all positions will be eventually searched.

### Another Hash()

What's the issue with the following hash function?

```c
int hash(char *key, int N)
{
	int h = 0;
	char *c;
	for (c = key; *c != '\0'; c++)
		h = h + *c;
	return h % N;
}
```

## Heaps

Max Heap insert the following.

`S  O  R  T  I  N  G  I  S  F  U  N`

### Building a heap visualizer

Let's do a fun little side coding activity (if we get time).  We'll build a visualizer that prints something out like

```c
Operation        nitems    [0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]
h = newHeap(10);      0     -   -   -   -   -   -   -   -   -   -   -
insert(h, 10);        1     -  10   -   -   -   -   -   -   -   -   -
insert(h,  5);        2     -  10   5   -   -   -   -   -   -   -   -
insert(h, 15);        3     -  15   5  10   -   -   -   -   -   -   -
insert(h,  3);        4     -  15   5  10   3   -   -   -   -   -   -
insert(h, 16);        5     -  16  15  10   3   5   -   -   -   -   -
insert(h, 13);        6     -  16  15  13   3   5  10   -   -   -   -
insert(h,  6);        7     -  16  15  13   3   5  10   6   -   -   -
it = delete(h);       6     -  15   6  13   3   5  10   -   -   -   -
insert(h,  2);        7     -  15   6  13   3   5  10   2   -   -   -
it = delete(h);       6     -  13   6  10   3   5   2   -   -   -   -
it = delete(h);       5     -  10   6   2   3   5   -   -   -   -   -
it = delete(h);       4     -   6   5   2   3   -   -   -   -   -   -
it = delete(h);       3     -   5   3   2   -   -   -   -   -   -   -
it = delete(h);       2     -   3   2   -   -   -   -   -   -   -   -
```

We'll keep it simple and do a 'tracing' method (i.e. we add visualisation code to the C code).

## Tries

![trie](assets/img/tri.png)

> The red nodes are 'finishing' nodes.

What are the keys?

Insert the following into a trie

`jaws boots axe boo so sore boot boon`

Does the order matter?
