# Week 9

## Properties of Sorting

- Stability
- Adaptability
- Comparison-based

## Algorithms

Some common sorting functions

```c
// functions on arrays of ints
void bubbleSort(int *, int, int);
void insertionSort(int *, int, int);
void mergeSort(int *, int, int);
void quickSort(int *, int, int);
void selectionSort(int *, int, int);
void shellSort(int *, int, int);
```

## Example

Given the following table sort it using a stable and a non stable sort based on student name.

| Course   | Name | Degree |
|----------|------|--------|
| COMP1927 | John |   3978 |
| COMP1927 | Pete |   3978 |
| MATH1231 | John |   3978 |
| MATH1231 | Adam |   3970 |
| PSYC1011 | Adam |   3970 |
| PSYC1011 | Jane |   3970 |

## Determining if a sort was stable or not

We need a copy of the original array to determine if the sort was stable.

```c
int isStableSort(int original[], int sorted[], int lo, int hi) { ... }
```

The course details a method that is very odd and convoluted;

> Also the code has a bunch of errors so I fixed those up

```c
typedef struct { int a; int b; } Item;

int isStableSort(Item original[], Item sorted[], int lo, int hi)
{
	int i, j, k, key;
	for (i = lo; i <= hi; i++) {
		key = sorted[i].a;
		// setting j=i means that we "find"
		// the current key in position i first
		j = i; k = 0;
		while (j <= hi and k <= hi) {
			// find next pair of items with (item.a == key)
			for (/*current_j*/; j <= hi; j++)
				if (sorted[j].a == key) break;
			for (/*current_k*/; k <= hi; k++)
				if (original[k].a == key) break;
			// check that they have the same item.b
			if (j <= hi && k <= hi) {
				if (sorted[j].b != sorted[k].b)
					return 0;
			}
		}
    }
	return 1;
}
```

> This is O(n^2) I believe (since k and j don't ever get reset and they always get bumped by 1 or function returns then they can loop a maximium of O(n) times and the outer loop is clearly O(n) so O(n^2))

### Example Sorts

Given the data;
```c
int nums[8] = { 4, 6, 2, 7, 8, 5, 1, 3 };
```

Show what happens for each call if called like `sort(nums, 0, 7)`

#### Selection

```c
void selectionSort(int a[], int lo, int hi) {

}
```

### Bubble

```c
void bubbleSort(int a[], int lo, int hi) {

}
```

### QuickSort

```c
// partition can be many things
// interestingly enough a random pivot point
// often is much better (I'll illustrate why but
// don't worry too much)
void quickSort(int a[], int lo, int hi) {
   int i; // index of pivot
   if (lo >= hi) return;
   i = partition(a, lo, hi);
   quickSort(a, lo, i-1);
   quickSort(a, i+1, hi);
}
```

Write a partition function!

### Immutable Selection Sort

Often we don't want to modify the original list.  Create a new list that is sorted.

?> Often it's easiest to just copy the list and then do your normal insertion sort on that.  But I feel that is kinda 'wrong' since you are wasting cycles by just copying it first.  Instead you can build a pretty nice insertion sort without having to do that.

?> Make it stable too (it'll make it easier todo)

```c
// Presuming linked list
// you can use the following methods

List newList(void);
void appendItem(List xs, int value);

List selectSort(List xs) {
    List list = newList(void);
    
    return list;
}
```

### Merging Sorted Lists

How would you merge two files given 2 files that contains already sorted text?

i.e. `./merge File1 File2` should output the merged (and sorted) outputs.  Make it linear in terms of the file sizes.

### Sorting Students

Given some student data in the form;

```
5059413  Daisy  3762  15
3461045  Dotty  3648  42
3474881  Daisy  8543  16
5061020  David  3970   3
```

- Read above into a structure of form `{zID, name, program, favouriteNumber}`
- Use qsort to sort it by defining a custom comparator
- Order is initially by name and then by zID
- Write out the sorted students line by line
- Use the following format for output `"%7d %-20s %4d %d\n"`

[](Tute9/Students.c ':include :type=code java')
